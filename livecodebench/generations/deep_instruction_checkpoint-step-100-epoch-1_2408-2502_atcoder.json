[
  {
    "question_id": "abc365_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find first and second largest elements\n    if n == 1:\n        print(1)\n        return\n        \n    max_val = -1\n    sec_max_val = -1\n    \n    for num in arr:\n        if num > max_val:\n            sec_max_val = max_val\n            max_val = num\n        elif max_val > num > sec_max_val:\n            sec_max_val = num\n            \n    print(sec_max_val)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    Y = int(input().strip())\n    \n    if (Y % 4 == 0 and Y % 100 != 0) or (Y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = [line.strip() for line in data[1:1+n]]\n    \n    # Find the maximum length of all strings\n    max_len = max(len(s) for s in strings)\n    \n    # Initialize result list with empty strings\n    result = ['' for _ in range(max_len)]\n    \n    # Process each string\n    for s in strings:\n        # Precompute prefix lengths for each character\n        prefix_lengths = {}\n        for char in set(s):\n            prefix_lengths[char] = []\n        \n        for i in range(1, len(s)):\n            prefix_lengths[s[i]].append(i)\n        \n        # Fill the result array\n        for i in range(n):\n            # Get all positions where current character appears\n            positions = prefix_lengths.get(strings[i][n - i], [])\n            \n            # Sort positions by their original index in the string\n            positions.sort(key=lambda x: x - (len(s) - i))\n            \n            # Place characters at these positions\n            for pos in positions:\n                result[pos] += strings[i][pos]\n                \n    # Print the result\n    print('\\n'.join(result))\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    t = int(data[1])\n    a = int(data[2])\n    \n    if (t + a) % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's a gap between waking up and going to bed\n    if B - C > 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    x = float(data)\n    \n    # Remove trailing zeros after the decimal point\n    if '.' in str(x):\n        parts = str(x).split('.')\n        integer_part, fractional_part = parts[0], parts[1]\n        \n        # Remove trailing zeros from fractional part\n        while fractional_part and fractional_part[-1] == '0':\n            fractional_part = fractional_part[:-1]\n            \n        result = f\"{integer_part}.{fractional_part}\"\n    else:\n        result = str(x)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Read the initial stack of cards\n    stack = list(map(int, data[2:2+n]))\n    \n    # Take the last k cards from the bottom\n    taken_cards = stack[-k:]\n    \n    # Remove these cards from the original stack\n    stack = stack[:-k]\n    \n    # Add the taken cards at the beginning of the stack\n    stack = taken_cards + stack\n    \n    # Output the result\n    print(' '.join(map(str, stack)))\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    count = 0\n    while len(arr) > 1:\n        # Find the maximum element\n        max_val = max(arr)\n        \n        # Decrease both occurrences of the maximum element by 1\n        for i in range(len(arr)):\n            if arr[i] == max_val:\n                arr[i] -= 1\n        \n        # Remove all zeros\n        arr = [x for x in arr if x != 0]\n        \n        # Increment the count\n        count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Check if A and B are equal\n    if A == B:\n        print(1)\n        return\n    \n    # Calculate the difference between A and B\n    diff = abs(A - B)\n    \n    # Find the range of x\n    min_x = max(1, A - diff)\n    max_x = min(100, B + diff)\n    \n    # Count numbers in the range [min_x, max_x]\n    count = max_x - min_x + 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    presses = []\n    \n    for i in range(1, n + 1):\n        a = int(data[i * 2 - 1])\n        s = data[i * 2]\n        presses.append((a, s))\n    \n    # Sort by key\n    presses.sort(key=lambda x: x[0])\n    \n    current_left = None\n    current_right = None\n    total_fatigue = 0\n    \n    for a, s in presses:\n        if s == 'L':\n            if current_left is None:\n                current_left = a\n            else:\n                total_fatigue += abs(a - current_left)\n                current_left = a\n        else:  # s == 'R'\n            if current_right is None:\n                current_right = a\n            else:\n                total_fatigue += abs(a - current_right)\n                current_right = a\n                \n    print(total_fatigue)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    matrix = []\n    for i in range(1, n + 1):\n        row = list(map(int, data[i:i+n]))\n        matrix.append(row)\n    \n    current_element = 1\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if current_element == i + 1:\n                current_element = matrix[current_element - 1][j]\n            else:\n                current_element = matrix[j][current_element - 1]\n    \n    print(current_element)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Create list of tuples (family_id, gender)\n    babies = []\n    index = 2\n    for i in range(m):\n        family_id = int(data[index]); index += 1\n        gender = data[index]; index += 1\n        babies.append((family_id, gender))\n    \n    # Sort by family ID, then by gender\n    babies.sort(key=lambda x: (x[0], x[1]))\n    \n    # Track which families have already had a boy\n    boys_in_families = set()\n    \n    result = []\n    for family_id, gender in babies:\n        if gender == 'M':\n            boys_in_families.add(family_id)\n        else:\n            # Check if there's a boy in this family\n            if family_id in boys_in_families:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n    \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    S = input().split()\n    \n    # Determine the order of ages\n    if S[0] == '<':\n        A = 'A'\n        B = 'B'\n        C = 'C'\n    else:\n        A = 'B'\n        B = 'A'\n        C = 'C'\n        \n    if S[1] == '<':\n        if S[2] == '<':\n            print(A)\n        else:\n            print(B)\n    else:\n        if S[2] == '<':\n            print(C)\n        else:\n            print(B)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    result = \"\"\n    for char in s:\n        if char != '.':\n            result += char\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    count = 0\n    for i in range(1, 13):\n        if len(data[i-1]) == i:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Create frequency array for characters 'A' through 'Z'\n    freq = [0] * 26\n    \n    # Count occurrences of each character\n    for char in data:\n        idx = ord(char) - ord('A')\n        freq[idx] += 1\n        \n    # Calculate prefix sums for positions\n    prefix_sum = [0] * 27\n    current_sum = 0\n    for i in range(26):\n        current_sum += freq[i]\n        prefix_sum[i + 1] = current_sum\n    \n    # Sort characters by their position in the alphabet\n    chars = sorted(zip(range(26), freq))\n    \n    total_distance = 0\n    for pos, count in chars:\n        # Distance to reach position pos\n        distance_to_pos = pos\n        # Distance to reach end of alphabet\n        distance_to_end = 26 - pos\n        # Total distance for this character\n        total_distance += distance_to_pos + distance_to_end\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    S = data[0].strip()\n    T = data[1].strip()\n    \n    min_diff = len(S) + len(T)\n    \n    for i in range(min(len(S), len(T))):\n        if S[i] != T[i]:\n            min_diff = min(min_diff, i + 1)\n            \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    if s.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    points = []\n    index = 1\n    \n    for _ in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Sort by angle with positive x-axis\n    def angle(p):\n        return math.atan2(p[1], p[0])\n    \n    sorted_points = sorted(points, key=angle)\n    \n    # Precompute distances between consecutive points\n    dists = []\n    for i in range(len(sorted_points)):\n        x1, y1 = sorted_points[i]\n        x2, y2 = sorted_points[(i+1) % len(sorted_points)]\n        dx = x2 - x1\n        dy = y2 - y1\n        dists.append(math.sqrt(dx*dx + dy*dy))\n    \n    # Compute prefix sums\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i-1] + dists[i-1]\n    \n    # Initialize DP table: dp[i][j] = minimum cost to visit first i points and end at j-th point\n    INF = float('inf')\n    dp = [[INF] * n for _ in range(n)]\n    \n    # Base case: start at origin\n    for i in range(n):\n        dp[0][i] = 0\n    \n    # Fill DP table using dynamic programming\n    for k in range(1, n):  # number of visited points\n        for i in range(k):  # current point being visited\n            for j in range(i):  # previous point visited\n                dp[k][i] = min(dp[k][i], dp[k-1][j] + prefix_sums[i+1] - prefix_sums[j+1])\n    \n    result = INF\n    for i in range(n):\n        result = min(result, dp[n][i] + prefix_sums[n] - prefix_sums[i+1])\n    \n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    import math\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '#' and s[i+2] == '#':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    \n    presses = list(map(int, data[2:2+n]))\n    current_time = 0\n    \n    count = 0\n    for t in presses:\n        if t - current_time >= c:\n            count += 1\n        current_time = t\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    grid = [line.strip() for line in data]\n    \n    n = len(grid)\n    m = len(grid[0])\n    \n    def count_valid_positions():\n        count = 0\n        \n        # Check each cell\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '.':\n                    valid = True\n                    \n                    # Check vertical capture\n                    for k in range(i + 1, n):\n                        if grid[k][j] == '#':\n                            valid = False\n                            break\n                    if not valid:\n                        continue\n                        \n                    # Check horizontal capture\n                    for k in range(j + 1, m):\n                        if grid[i][k] == '#':\n                            valid = False\n                            break\n                    if not valid:\n                        continue\n                        \n                    count += 1\n        \n        return count\n    \n    result = count_valid_positions()\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if all characters are already in correct positions\n    for i in range(3):\n        if s[i] != chr(ord('A') + i):\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse collection dates and reminders\n    collection_dates = []\n    reminders = []\n    index = 1\n    for _ in range(n):\n        q = int(data[index]); r = int(data[index+1])\n        collection_dates.append(q)\n        reminders.append(r)\n        index += 2\n    \n    # Parse queries\n    q = int(data[index])\n    queries = []\n    index += 1\n    for _ in range(q):\n        t = int(data[index]); d = int(data[index+1])\n        queries.append((t, d))\n        index += 2\n    \n    # Precompute powers of 2 up to 10^9\n    mod = 10**9 + 7\n    max_power = 10**9\n    power_of_two = [1] * (max_power + 1)\n    for i in range(1, max_power + 1):\n        power_of_two[i] = (power_of_two[i - 1] * 2) % mod\n    \n    # Precompute modular inverses using Fermat's Little Theorem\n    inv_mod = [1] * (max_power + 1)\n    inv_mod[0] = 0\n    inv_mod[1] = 1\n    for i in range(2, max_power + 1):\n        inv_mod[i] = (mod - mod // i) * inv_mod[mod % i] % mod\n    \n    # Precompute modular exponentiation\n    def pow_mod(base, exp, mod):\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp & 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp >>= 1\n        return result\n    \n    # Precompute modular multiplicative inverse\n    def mod_inv(a, mod):\n        return pow_mod(a, mod - 2, mod)\n    \n    # Precompute modular exponentiation with modular inverse\n    def pow_mod_inv(base, exp, mod):\n        return (pow_mod(base, exp, mod) * mod_inv(mod, mod)) % mod\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv2 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv2[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv3 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv3[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv4 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv4[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv5 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv5[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv6 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv6[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv7 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv7[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv8 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv8[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv9 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv9[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv10 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv10[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv11 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv11[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv12 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv12[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv13 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv13[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv14 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv14[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv15 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv15[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv16 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv16[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv17 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv17[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv18 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv18[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv19 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv19[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv20 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv20[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv21 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv21[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv22 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv22[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv23 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv23[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv24 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv24[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv25 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv25[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv26 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv26[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv27 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv27[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv28 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv28[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv29 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv29[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv30 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv30[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv31 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv31[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv32 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv32[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv33 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv33[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv34 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv34[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv35 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv35[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv36 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv36[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv37 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv37[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv38 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv38[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv39 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv39[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv40 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv40[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv41 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv41[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv42 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv42[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv43 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv43[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv44 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv44[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv45 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv45[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv46 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv46[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv47 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv47[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv48 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv48[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv49 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv49[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv50 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv50[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv51 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv51[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv52 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv52[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv53 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv53[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv54 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv54[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv55 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv55[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv56 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv56[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv57 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv57[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv58 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv58[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv59 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv59[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv60 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv60[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv61 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv61[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv62 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv62[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv63 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv63[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv64 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv64[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv65 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv65[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv66 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv66[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv67 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv67[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv68 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv68[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv69 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv69[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv70 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv70[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv71 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv71[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv72 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv72[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv73 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv73[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv74 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv74[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv75 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv75[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv76 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv76[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv77 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv77[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv78 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv78[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv79 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv79[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv80 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv80[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv81 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv81[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv82 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv82[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv83 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv83[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all possible bases\n    mod_exp_inv84 = [[None] * (max_power + 1) for _ in range(max_power + 1)]\n    for b in range(1, max_power + 1):\n        for e in range(1, max_power + 1):\n            mod_exp_inv84[b][e] = pow_mod_inv(b, e, mod)\n    \n    # Precompute modular exponentiation with modular inverse for all"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    colors = [int(x) for x in data]\n    \n    count = {}\n    for color in colors:\n        if color not in count:\n            count[color] = 0\n        count[color] += 1\n    \n    max_count = max(count.values())\n    result = max_count // 2\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1]\n    \n    max_count = 0\n    \n    # Check all possible starting positions for substrings of length k\n    for i in range(n - k + 1):\n        substring = s[i:i+k]\n        count = substring.count('O')\n        if count > max_count:\n            max_count = count\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data.isdigit() or len(data) != 3:\n        print(\"Invalid input\")\n        return\n        \n    n = int(data)\n    \n    # Extract digits\n    a = n // 100\n    b = (n // 10) % 10\n    c = n % 10\n    \n    # Form new numbers\n    num1 = 100 * b + 10 * c + a\n    num2 = 100 * c + 10 * a + b\n    \n    print(f\"{num1} {num2}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Convert number to string for easy character manipulation\n    num_str = str(n)\n    \n    # Count occurrences of each digit\n    count_1 = num_str.count('1')\n    count_2 = num_str.count('2')\n    count_3 = num_str.count('3')\n    \n    # Check conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().strip()\n    \n    # Find the position where the first '|' appears\n    pos = data.find('|')\n    \n    if pos == -1:\n        print(\"1\")\n        return\n        \n    # Extract the substring after the last '|'\n    part = data[pos+1:]\n    \n    # Split the substring into parts based on '-' characters\n    parts = part.split('-')\n    \n    # Convert each part to integer and store in list\n    result = [int(part) for part in parts]\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    if len(s) != n:\n        print(\"No\")\n        return\n        \n    # Check if the first character is '1'\n    if s[0] != '1':\n        print(\"No\")\n        return\n        \n    # Check if the last character is '/'\n    if s[-1] != '/':\n        print(\"No\")\n        return\n        \n    # Check if the second character is '/'\n    if s[1] == '/':\n        print(\"No\")\n        return\n        \n    # Check if the third character is '2'\n    if s[2] != '2':\n        print(\"No\")\n        return\n        \n    # Check if the rest of the string is composed only of '1's and '/'\n    for i in range(3, len(s)):\n        if s[i] != '1' and s[i] != '/':\n            print(\"No\")\n            return\n            \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    \n    # Check if the length is even\n    if len(data) % 2 != 0:\n        print(\"No\")\n        return\n        \n    # Count frequency of each character\n    char_count = {}\n    for char in data:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            \n    # Check if each character appears exactly twice\n    for count in char_count.values():\n        if count != 2:\n            print(\"No\")\n            return\n            \n    # Check if each character appears at most once\n    for count in char_count.values():\n        if count > 1:\n            print(\"No\")\n            return\n            \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = list(data[1])\n    \n    # Count initial number of empty boxes\n    empty_count = sum(1 for char in s if char == '.')\n    \n    # Simulate eating cookies over D days\n    for _ in range(d):\n        # Find all positions with cookies\n        cookie_positions = [i for i, char in enumerate(s) if char == '@']\n        \n        # Remove the first position (the earliest)\n        cookie_positions.pop(0)\n        \n        # Add new position (current position + 1)\n        new_position = len(cookie_positions)\n        cookie_positions.append(new_position)\n        \n        # Update the string\n        for pos in cookie_positions:\n            s[pos] = '.'\n    \n    # Count remaining empty boxes\n    result = empty_count - len(cookie_positions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = list(data[1])\n    \n    # Initialize result array\n    result = ['.'] * n\n    \n    # Process each day\n    for _ in range(d):\n        # Find the last position where there's a cookie\n        last_pos = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == '@':\n                last_pos = i\n                break\n                \n        # If no cookie found, all positions are already empty\n        if last_pos == -1:\n            continue\n            \n        # Set the cookie at the last position to '.'\n        result[last_pos] = '.'\n        \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    times = list(map(int, data[1:1+n]))\n    volumes = list(map(int, data[1+n:1+2*n]))\n    \n    current_time = 0\n    current_water = 0\n    \n    for i in range(n):\n        if current_time + 1 <= times[i]:\n            current_time += 1\n            current_water += volumes[i]\n            \n    print(current_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    r = int(data[1])\n    \n    divs = []\n    for i in range(2, 2 + n):\n        d = int(data[i])\n        a = int(data[i + 1])\n        if d == 1:\n            divs.append((a, True))\n        else:\n            divs.append((a, False))\n    \n    current_rating = r\n    for a, update in divs:\n        if update:\n            current_rating += a\n    \n    print(current_rating)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    c1 = data[1].strip()\n    c2 = data[2].strip()\n    s = data[3].strip()\n    \n    result = []\n    for char in s:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    \n    total = A + B + C\n    \n    if total % 2 == 0:\n        target_sum = total // 2\n        # Check if there exists a subset of {A, B} that sums up to target_sum - C\n        found = False\n        for i in range(1 << len([A, B])):\n            current_sum = 0\n            for j in range(len([A, B])):\n                if i & (1 << j):\n                    current_sum += [A, B][j]\n            if current_sum == target_sum - C:\n                found = True\n                break\n        if found:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    H, W, X, Y = map(int, data[0].split())\n    \n    grid = []\n    for i in range(1, H + 1):\n        grid.append(data[i].strip())\n    \n    T = data[H + 1]\n    \n    x, y = X - 1, Y - 1\n    \n    visited = set()\n    visited.add((x, y))\n    \n    for char in T:\n        new_x, new_y = x, y\n        \n        if char == 'U' and 0 <= new_x - 1 < H and grid[new_x - 1][new_y] != '#':\n            new_x -= 1\n            \n        elif char == 'D' and 0 <= new_x + 1 < H and grid[new_x + 1][new_y] != '#':\n            new_x += 1\n            \n        elif char == 'L' and 0 <= new_y - 1 < W and grid[new_x][new_y - 1] != '#':\n            new_y -= 1\n            \n        elif char == 'R' and 0 <= new_y + 1 < W and grid[new_x][new_y + 1] != '#':\n            new_y += 1\n            \n        visited.add((new_x, new_y))\n        \n        x, y = new_x, new_y\n        \n    print(f\"{x + 1} {y + 1} {len(visited)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    # Count occurrences of each number\n    count_A = A == B\n    count_B = B == C\n    count_C = C == D\n    \n    # Check for full house conditions\n    if (count_A and count_B) or (count_B and count_C) or (count_C and count_D):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Precompute powers of 10 for each digit position\n    power_of_ten = [1]\n    for i in range(1, 10):\n        power_of_ten.append(power_of_ten[-1] * 10)\n    \n    # Find the longest prefix that matches the beginning of the string\n    max_prefix_length = 0\n    for i in range(n):\n        if data[:i+1] == str(i):\n            max_prefix_length = i + 1\n    \n    # Calculate the remaining part after the longest match\n    remaining_part = data[max_prefix_length:]\n    \n    # Count the number of digits in the remaining part\n    count_digits = sum(1 for char in remaining_part if char.isdigit())\n    \n    # Calculate the number of button presses needed\n    result = max_prefix_length + count_digits\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]