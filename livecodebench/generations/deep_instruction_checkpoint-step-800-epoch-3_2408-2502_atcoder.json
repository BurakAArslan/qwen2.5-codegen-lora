[
  {
    "question_id": "abc365_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_max = -1\n    second_max = -1\n    \n    for num in arr:\n        if num > first_max:\n            second_max = first_max\n            first_max = num\n        elif first_max > num > second_max:\n            second_max = num\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    Y = int(input().strip())\n    \n    if (Y % 4 == 0 and Y % 100 != 0) or (Y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    max_len = len(strings[0])\n    result = []\n    \n    for k in range(max_len):\n        pattern = list('*' * (k + 1))\n        \n        # Check if all strings have sufficient characters at position k+1\n        valid = True\n        for s in strings:\n            if k + 1 < len(s):\n                if s[k] != '*':\n                    valid = False\n                    break\n        \n        if not valid:\n            continue\n            \n        # Generate all possible sequences for the remaining positions\n        def generate_sequences(position, current_seq):\n            if position == max_len:\n                result.append(''.join(current_seq))\n                return\n                \n            for char in ['a', 'b', 'c', '*', 'd', 'e', 'f', 'g', 'h', 'i', 'j']:\n                new_seq = current_seq[:]\n                new_seq.append(char)\n                generate_sequences(position + 1, new_seq)\n                \n        generate_sequences(1, pattern)\n    \n    # Sort the results by their first character\n    result.sort()\n    \n    # Print the results\n    for t in result:\n        print(t)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    T = int(data[1])\n    A = int(data[2])\n    \n    if T > (N // 2) or A > (N // 2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's any hour where he wakes up and is awake\n    for hour in range(A, C):\n        if hour >= B:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "def main():\n    X = float(input().strip())\n    \n    # Remove trailing zeros and convert to string\n    str_x = str(X).rstrip('0').rstrip('.')\n    \n    print(str_x)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    cards = list(map(int, data[2:2+n]))\n    \n    top_k_elements = cards[-k:]\n    remaining_cards = cards[:-k]\n    \n    result = top_k_elements + remaining_cards\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    count = 0\n    while len(arr) > 1:\n        sorted_arr = sorted(arr, reverse=True)\n        sorted_arr[0] -= 1\n        if sorted_arr[1] != 0:\n            sorted_arr[1] -= 1\n        else:\n            # Find first non-zero element after sorting\n            for i in range(1, len(sorted_arr)):\n                if sorted_arr[i] != 0:\n                    sorted_arr[i] -= 1\n                    break\n        count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def main():\n    A, B = map(int, input().split())\n    \n    count = 0\n    \n    # Check x = A + d\n    d = B - A\n    if 2 * A <= B <= 2 * A + d:\n        count += 1\n        \n    # Check x = B + d  \n    if 2 * B >= A >= B + d:\n        count += 1\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    presses = []\n    index = 1\n    \n    for _ in range(n):\n        a = int(data[index]); s = data[index + 1]\n        index += 2\n        presses.append((a, s))\n    \n    positions = [None] * 101\n    operations = []\n    \n    for a, s in presses:\n        if s == 'L':\n            # Use right hand initially\n            pos = a\n            operations.append(('R', pos))\n        else:  # s == 'R'\n            # Use left hand initially\n            pos = a\n            operations.append(('L', pos))\n        \n        # Track position\n        if s == 'L':\n            operations.append(('move', pos, pos - 1))\n        else:  # s == 'R'\n            operations.append(('move', pos, pos + 1))\n    \n    # Sort operations by type and then position\n    operations.sort(key=lambda op: (op[0], op[1]))\n    \n    current_pos = None\n    total_cost = 0\n    \n    for op_type, pos in operations:\n        if op_type == 'L' or op_type == 'R':\n            # Update position\n            if current_pos is not None:\n                total_cost += abs(current_pos - pos)\n            current_pos = pos\n        \n        elif op_type == 'move':\n            # Handle movement operation\n            old_pos, new_pos = pos\n            total_cost += abs(new_pos - old_pos)\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"Yes\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    combinations = []\n    index = 1\n    \n    for _ in range(n):\n        row = list(map(int, data[index:index + n]))\n        combinations.append(row)\n        index += n\n    \n    result = 1\n    for i in range(1, n + 1):\n        result = combinations[result - 1][i - 1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    families = [[] for _ in range(n+1)]\n    \n    index = 2\n    for _ in range(m):\n        a = int(data[index]); b = data[index+1]\n        index += 2\n        \n        if b == 'M':\n            families[a].append('Taro')\n        else:\n            families[a].append('Sanae')\n            \n    results = []\n    for i in range(1, n+1):\n        if families[i]:\n            if families[i][0] == 'Taro':\n                results.append('Yes')\n            else:\n                results.append('No')\n                \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    S = input().split()\n    \n    # Determine the order: A is the one with the most restrictive condition\n    if (S[0] == '<' and S[1] == '<') or (S[0] == '>' and S[1] == '>'):\n        A = 'A'\n    elif (S[0] == '<' and S[1] == '>') or (S[0] == '>' and S[1] == '<'):\n        A = 'B'\n    else:\n        A = 'C'\n        \n    print(A)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "def main():\n    S = input().strip()\n    result = []\n    i = 0\n    while i < len(S):\n        if S[i] == '.':\n            i += 1\n        else:\n            result.append(S[i])\n            i += 1\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "import sys\n\ndef main():\n    strings = []\n    for line in sys.stdin:\n        strings.append(line.strip())\n    \n    count = 0\n    for i in range(1, 13):\n        if len(strings[i-1]) == i:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    \n    # Create arrays for positions of letters A-Z\n    target_positions = [ord(c) - ord('A') for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ']\n    current_position = ord('A') - ord('A')\n    \n    total_distance = 0\n    \n    for char in S:\n        pos = ord(char) - ord('A')\n        distance = abs(pos - current_position)\n        total_distance += distance\n        current_position = pos\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    # Check if strings are equal\n    if S == T:\n        print(0)\n    else:\n        # Find first differing character\n        for i in range(min(len(S), len(T))):\n            if S[i] != T[i]:\n                print(i + 1)  # Return 1-based index\n                return\n                \n        # If all characters matched up to min(length), compare lengths\n        if len(S) == len(T):\n            print(0)\n        elif len(S) < len(T):\n            print(len(S) + 1)  # Position after last character in S\n        else:\n            print(len(T) + 1)  # Position after last character in T\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    S = input().strip()\n    if S.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import math\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    points = []\n    index = 1\n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Calculate Manhattan distance between consecutive points\n    total_manhattan = 0.0\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        dx = abs(x1 - x2)\n        dy = abs(y1 - y2)\n        total_manhattan += max(dx, dy)\n    \n    # Calculate Euclidean distance from last point back to start\n    last_x, last_y = points[n-1]\n    first_x, first_y = points[0]\n    euclidean_cost = math.sqrt((last_x - first_x)**2 + (last_y - first_y)**2)\n    \n    print(f\"{total_manhattan + euclidean_cost:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '.' and s[i+2] == '#':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    C = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    \n    count = 0\n    current_time = 0\n    \n    for t in times:\n        if t - current_time >= C:\n            count += 1\n            current_time = t\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    lines = []\n    for _ in range(8):\n        lines.append(input().strip())\n    \n    count = 0\n    \n    for i in range(8):  # rows\n        for j in range(8):  # columns\n            if lines[i][j] == '.':\n                valid = True\n                \n                # Check if this cell is safe from horizontal captures\n                for r in range(8):\n                    if lines[r][j] == '#' and r != i:\n                        valid = False\n                        break\n                \n                # Check if this cell is safe from vertical captures  \n                for c in range(8):\n                    if lines[i][c] == '#' and c != j:\n                        valid = False\n                        break\n                \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    S = input().strip()\n    \n    # Check if all three characters appear at least once\n    if 'A' not in S or 'B' not in S or 'C' not in S:\n        print(\"No\")\n        return\n        \n    # Check if we have exactly one of each character\n    freq = {}\n    for char in S:\n        freq[char] = freq.get(char, 0) + 1\n    \n    if len(freq) == 3 and freq['A'] == 1 and freq['B'] == 1 and freq['C'] == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse collection intervals\n    intervals = []\n    idx = 1\n    for _ in range(n):\n        q = int(data[idx]); r = int(data[idx+1]); idx += 2\n        intervals.append((q, r))\n    \n    q_queries = []\n    # Parse query information\n    for _ in range(int(data[idx])):\n        t = int(data[idx+1]); d = int(data[idx+2]); idx += 3\n        q_queries.append((t, d))\n    \n    # Precompute next_collection array\n    next_collection = [0] * (10**9 + 1)\n    for q_val, r_val in intervals:\n        for day in range(r_val, 10**9 + 1, q_val):\n            next_collection[day] = day + q_val\n    \n    # Process queries\n    results = []\n    for t, d in q_queries:\n        target_day = d - 1\n        if target_day >= len(next_collection):\n            results.append(str(target_day))\n        else:\n            results.append(str(next_collection[target_day]))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "from collections import Counter\n\ndef main():\n    # Read input\n    A = list(map(int, input().split()))\n    \n    # Count frequency of each color\n    count_dict = Counter(A)\n    \n    max_operations = 0\n    \n    # Try all possible pairs of colors\n    for r in range(1, 5):  # From 1 to 4\n        # Calculate maximum number of complete groups of size r\n        max_groups = count_dict[1] // r\n        \n        # Add the remainder to the count\n        max_operations += max_groups\n    \n    print(max_operations)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1]\n    \n    count = 0\n    max_count = 0\n    \n    for i in range(n):\n        if s[i] == 'O':\n            count += 1\n            if count >= k:\n                max_count += 1\n                count -= 1\n        else:\n            count = 0\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Extract digits\n    hundreds_digit = n // 100\n    tens_digit = (n // 10) % 10\n    ones_digit = n % 10\n    \n    # Form the two new numbers\n    first_number = int(f\"{tens_digit}{ones_digit}{hundreds_digit}\")\n    second_number = int(f\"{c}{a}{b}\")\n    \n    print(f\"{first_number} {second_number}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    n = input().strip()\n    \n    # Count frequency of each digit\n    freq = {}\n    for char in n:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check conditions\n    has_one = '1' in freq and freq['1'] == 1\n    has_two = '2' in freq and freq['2'] == 2\n    has_three = '3' in freq and freq['3'] == 3\n    \n    # Output \"Yes\" or \"No\"\n    if has_one and has_two and has_three:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    \n    # Find all occurrences of '|' and '-'\n    positions = []\n    current_pos = 0\n    \n    while True:\n        pos = S.find('|', current_pos)\n        if pos == -1:\n            break\n            \n        positions.append(pos)\n        current_pos = pos + 1\n    \n    # Extract numbers from each segment\n    segments = []\n    for i in range(len(positions)):\n        start = positions[i] + 1  # Skip the '|'\n        end = positions[i + 1] if i < len(positions) - 1 else len(S)\n        \n        # Count '-' characters in this segment\n        count = 0\n        for j in range(start, end):\n            if S[j] == '-':\n                count += 1\n                \n        segments.append(count)\n    \n    # The number of segments is N+1\n    N = len(segments)\n    \n    # Reconstruct the original sequence\n    A = [segments[i] for i in range(N)]\n    \n    print(' '.join(map(str, A)))\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip('/')\n    \n    if n % 2 == 0:\n        print(\"No\")\n        return\n        \n    first_half = s[:n//2]\n    second_half = s[n//2:]\n    \n    if '3' in first_half or '3' in second_half:\n        print(\"No\")\n        return\n        \n    if first_half != second_half:\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if length is even\n    n = len(s)\n    if n % 2 != 0:\n        print(\"No\")\n        return\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if all frequencies are 0 or 2\n    valid = True\n    for count in freq.values():\n        if count != 0 and count != 2:\n            valid = False\n            break\n    \n    if valid:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1]\n    \n    count_at = s.count('@')\n    initial_empty = n - count_at\n    \n    result = max(0, initial_empty + d)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1]\n    \n    # Precompute prefix sums for all positions\n    prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] + (1 if s[i - 1] == '@' else 0)\n    \n    result = []\n    for i in range(n):\n        # For position i, consider the segment from i+1 to n\n        L = i + 1\n        R = n\n        \n        # Find first occurrence of 'A' in segment [L, R]\n        low_L = L\n        high_L = R\n        while low_L <= high_L:\n            mid = (low_L + high_L) // 2\n            if s[mid] == '@':\n                high_L = mid - 1\n            else:\n                low_L = mid + 1\n        \n        low_R = L\n        high_R = R\n        while low_R <= high_R:\n            mid = (low_R + high_R) // 2\n            if s[mid] == '@':\n                low_R = mid + 1\n            else:\n                high_R = mid - 1\n        \n        # Calculate number of complete cycles\n        full_cycles = (prefix[R] - prefix[L]) // (d + 1)\n        \n        # Remaining cookies after full cycles\n        remaining = prefix[R] - prefix[L] % (d + 1)\n        \n        # Check if we can place a cookie at position i\n        if remaining >= low_R - L:\n            result.append('@')\n        else:\n            result.append('.')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    total_water = 0\n    \n    index = 1\n    for _ in range(n):\n        t = int(data[index]); v = int(data[index + 1])\n        index += 2\n        \n        if t <= 1:\n            total_water += v\n        else:\n            total_water -= (t - 1)\n            total_water += v\n            \n    print(total_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    R = int(data[1])\n    \n    divs = []\n    index = 2\n    for i in range(n):\n        d = int(data[index]); a = int(data[index + 1])\n        index += 2\n        if d == 1:\n            divs.append((a))\n        else:\n            divs.append(-a)\n            \n    current_rating = R\n    for a in divs:\n        current_rating += a\n        \n    print(current_rating)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    \n    n = int(data[0].strip())\n    c1 = data[1].strip()\n    c2 = data[2].strip()\n    s = data[3].strip()\n    \n    result = ''.join([c2 if char != c1 else char for char in s])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    total = A + B + C\n    if total % 2 == 0:\n        target = total // 2\n        found = False\n        for i in range(target + 1):\n            if i * 2 == total:\n                continue\n            j = (total - i) // 2\n            if i <= j and i + j == total // 2:\n                found = True\n                break\n        print(\"Yes\" if found else \"No\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    H, W, X, Y = map(int, data[0].split())\n    \n    grid = []\n    for i in range(1, 1 + H):\n        grid.append(data[i].strip())\n    \n    T = data[1 + H]\n    \n    current_x, current_y = X - 1, Y - 1\n    \n    visited = set()\n    visited.add((current_x, current_y))\n    \n    for action in T:\n        new_x, new_y = current_x, current_y\n        \n        if action == 'U' and current_x > 0 and grid[current_x - 1][current_y] != '#':\n            new_x -= 1\n            \n        elif action == 'D' and current_x < H - 1 and grid[current_x + 1][current_y] != '#':\n            new_x += 1\n            \n        elif action == 'L' and current_y > 0 and grid[current_x][current_y - 1] != '#':\n            new_y -= 1\n            \n        elif action == 'R' and current_y < W - 1 and grid[current_x][current_y + 1] != '#':\n            new_y += 1\n            \n        else:\n            continue\n            \n        visited.add((new_x, new_y))\n        current_x, current_y = new_x, new_y\n    \n    print(f\"{current_x + 1} {current_y + 1} {len(visited)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    count_A = 0\n    count_B = 0\n    count_C = 0\n    \n    if A == B:\n        count_A += 1\n    if A == C:\n        count_C += 1\n    if A == D:\n        count_D += 1\n        \n    if B == C:\n        count_B += 1\n    if B == D:\n        count_D += 1\n    if C == D:\n        count_D += 1\n        \n    counts = [count_A, count_B, count_C, count_D]\n    \n    for count in counts:\n        if count == 3:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    \n    # Precompute all prefixes that contain '3' or '7'\n    prefix_with_3 = []\n    for i in range(len(S) + 1):\n        if '3' in S[:i] or '7' in S[:i]:\n            prefix_with_3.append(i)\n    \n    # Precompute all suffixes that contain '3' or '7'\n    suffix_with_3 = []\n    for i in range(len(S)):\n        if '3' in S[i:] or '7' in S[i:]:\n            suffix_with_3.append(i)\n    \n    # Find the closest distance between prefix and suffix containing '3' or '7'\n    min_distance = float('inf')\n    for p in prefix_with_3:\n        if p in suffix_with_3:\n            min_distance = min(min_distance, p)\n    \n    # Calculate minimum button presses\n    presses = len(prefix_with_3) + len(suffix_with_3) - 1 - min_distance\n    \n    print(presses)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]