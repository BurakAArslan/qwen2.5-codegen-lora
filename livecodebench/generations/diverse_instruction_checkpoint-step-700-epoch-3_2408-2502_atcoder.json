[
  {
    "question_id": "abc365_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_max = -1\n    second_max = -1\n    \n    for i in range(n):\n        if arr[i] > first_max:\n            second_max = first_max\n            first_max = arr[i]\n        elif arr[i] > second_max and arr[i] != first_max:\n            second_max = arr[i]\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    Y = int(input().strip())\n    \n    if Y % 4 != 0:\n        print(365)\n    elif Y % 100 == 0:\n        if Y % 400 == 0:\n            print(366)\n        else:\n            print(365)\n    else:\n        print(366)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    \n    # Read all strings\n    strings = []\n    for i in range(1, 1+n):\n        strings.append(data[i].strip())\n    \n    # Find maximum length\n    max_len = max(len(s) for for s in strings)\n    \n    # Initialize result list\n    result = []\n    \n    # Process each position\n    for pos in range(max_len):\n        # Create candidate string by taking first character from each string\n        candidate = \"\"\n        for s in strings:\n            if pos < len(s):\n                candidate += s[pos]\n        \n        # Check if candidate can be extended with *\n        valid = True\n        for s in strings:\n            if pos >= len(s):\n                continue\n                \n            # Check if candidate ends with non-star character\n            if candidate[-1] != '*' and candidate[-1] != s[pos]:\n                valid = False\n                break\n        \n        # If valid, add candidate to result\n        if valid:\n            result.append(candidate)\n        else:\n            # Add star at this position\n            result.append('*')\n    \n    # Print all resulting strings\n    for t in result:\n        print(t)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    t = int(data[1])\n    a = int(data[2])\n    \n    if (n - t) > a:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's any overlap between sleep period and waking period\n    if max(A, B) < min(C - 1, 23):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "def main():\n    x = float(input().strip())\n    \n    # Remove trailing zeros and unnecessary decimal points\n    if '.' in str(x):\n        parts = str(x).split('.')\n        integer_part, decimal_part = parts[0], parts[1]\n        \n        # Remove trailing zeros from decimal part\n        while len(decimal_part) > 1 and decimal_part[-1] == '0':\n            decimal_part = decimal_part[:-1]\n            \n        # If no decimal part remains, keep only the integer part\n        if not decimal_part:\n            print(integer_part)\n        else:\n            # Add back the decimal point if necessary\n            if decimal_part != '':\n                print(f\"{integer_part}.{decimal_part}\")\n            else:\n                print(integer_part)\n    else:\n        # No decimal point means no unnecessary characters\n        print(str(x))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    k = int(data[1])\n    arr = list(map(int, data[2:2+n]))\n    \n    # Take last k elements (bottom k)\n    taken = arr[-k:]\n    \n    # Remove these elements from original array\n    remaining = arr[:-k]\n    \n    # Append taken elements at the end\n    result = remaining + taken\n    \n    # Output the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Count initial ones\n    count_one = sum(1 for x in arr if x == 1)\n    \n    # If all elements are already zero, return 0\n    if count_one == 0:\n        print(0)\n        return\n    \n    # Calculate total operations needed to make all zeros\n    total_operations = 0\n    while True:\n        # Find first non-zero element\n        i = 0\n        while i < len(arr) and arr[i] == 0:\n            i += 1\n        \n        # If we reached end without finding any non-zero, break\n        if i == len(arr):\n            break\n            \n        # Find last non-zero element\n        j = len(arr) - 1\n        while j >= 0 and arr[j] == 0:\n            j -= 1\n            \n        # If we reached start without finding any non-zero, break\n        if j < 0:\n            break\n            \n        # Calculate how many operations needed for this segment\n        segment_length = j - i + 1\n        operations_for_segment = segment_length // 2\n        total_operations += operations_for_segment\n        \n        # Decrease all elements in this segment by 1\n        for k in range(i, j + 1):\n            arr[k] -= 1\n    \n    # Subtract the extra operations due to the initial ones\n    result = total_operations - count_one\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def main():\n    A, B = map(int, input().split())\n    \n    # Check each candidate value of x\n    count = 0\n    for x in range(-100, 101):  # We'll check a reasonable range\n        # Generate all permutations of (x, A, B)\n        permutations = [(x, A, B), (A, x, B), (B, A, x)]\n        \n        valid = True\n        for perm in permutations:\n            a, b, c = perm\n            if abs(b - a) != abs(c - b):\n                valid = False\n                break\n                \n        if valid:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Initialize arrays for positions for states\n    pos_left = [0] * 101\n    pos_right = [0] * 101\n    \n    # Parse initial placements\n    idx = 1\n    for i in range(n):\n        a = int(data[idx]); s = data[idx + 1]\n        idx += 2\n        if s == 'L':\n            pos_left[a] = i\n        else:  # s == 'R'\n            pos_right[a] = i\n            \n    total_fatigue = 0\n    \n    # Process each position\n    for i in range(1, 101):\n        if pos_left[i] != 0:\n            # Left hand already occupied\n            pass\n        elif pos_right[i] != 0:\n            # Right hand already occupied\n            pass\n        else:\n            # Neither hand occupied, add to total\n            total_fatigue += i\n            \n    print(total_fatigue)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 1:\n        print(\"Invalid\")\n    elif L == 1 or R == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    matrix = []\n    index = 1\n    \n    for i in range(n):\n        row = list(map(int, data[index:index + n]))\n        matrix.append(row)\n        index += n\n        \n    current_element = 1\n    for i in range(n):\n        for j in range(i + 1):\n            current_element = matrix[current_element - 1][j]\n            \n    print(current_element)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Create list of lists: index i represents family i+1, value is gender\n    families = []\n    idx = 2\n    for i in range(n):\n        family_id = int(data[idx]) - 1         gender = data[idx + 1]\n        idx += 2\n        families.append(gender)\n    \n    # Initialize result array with 'No'\n    result = ['No'] * m\n    \n    # Process each baby's information\n    for i in range(m):\n        family_id = int(data[idx]) - 1\n        gender = data[idx + 1]\n        idx += 2\n        \n        # Check if this baby is the earliest born male in his/her family\n        if gender == 'M' and family_id == 0:\n            result[i] = 'Yes'\n    \n    # Print results\n    print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    s_ab = input().strip()\n    s_ac = input().strip()\n    s_bc = input().strip()\n    \n    # Determine ages based on given inequalities\n    if s_ab == '<':\n        a_b = True  # A < B\n    else:\n        a_b = False  # A >= B\n    \n    if s_ac == '<':\n        a_c = True  # A < C\n    else:\n        a_c = False  # A >= C\n        \n    if s_bc == '<':\n        b_c = True  # B < C\n    else:\n        b_c = False  # B >= C\n        \n    # Check possible configurations\n    config1 = (a_b, a_c, b_c)  # A < B, A < C, B < C\n    config2 = (a_b, a_c, not b_c)  # A < B, A < C, B > C\n    config3 = (not a_b, a_c, b_c)  # A >= B, A < C, B < C\n    config4 = (not a_b, a_c, not b_c)  # A >= B, A < C, B > C\n    config5 = (not a_b, not a_c, b_c)  # A >= B, A >= C, B < C\n    config6 = (not a_b, not a_c, not b_c)  # A >= B, A >= C, B > C\n    \n    # Find the configuration where B is the middle brother\n    for config1: print('A')\n    elif config2: print('B')\n    elif config3: print('C')\n    elif config4: \n        if a_b:\n            print('B')\n        else:\n            print('C')\n    elif config5: \n        if a_b:\n            print('B')\n        else:\n            print('C')\n    elif config6: \n        if a_b:\n            print('B')\n        else:\n            print('C')\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "def main():\n    S = input().strip()\n    result = []\n    for char in S:\n        if char != '.':\n            result.append(char)\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "import sys\n\ndef main():\n    # Read all lines from stdin\n    data = sys.stdin.read().splitlines()\n    \n    # Count occurrences of each length\n    counts = {}\n    for line in data:\n        length = len(line)\n        if length not in counts:\n            counts[length] = 0\n        counts[length] += 1\n    \n    # Find lengths where count equals length itself\n    result = 0\n    for length, count in counts.items():\n        if length == count:\n            result += 1\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "import sys\n\ndef main():\n    S = sys.stdin.readline().strip()\n    \n    # Create mapping: character -> position\n    char_to_pos = {}\n    for i, ch in enumerate(S):\n        char_to_pos[ch] = i + 1\n    \n    # Calculate total distance\n    total_distance = 0\n    current_position = 1  # Start at 'A' (position 1)\n    \n    for ch in S:\n        pos = char_to_pos[ch]\n        distance = abs(pos - current_position)\n        total_distance += distance\n        current_position = pos\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    S = data[0].strip()\n    T = data[1].strip()\n    \n    min_length = min(len(S), len(T))\n    \n    for i in range(min_length):\n        if S[i] != T[i]:\n            print(i + 1)\n            return\n    \n    # If all characters match up to the minimum length, compare lengths\n    if len(S) == len(T):\n        print(0)\n    else:\n        print(min_length + 1)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    S = input().strip()\n    if S.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import math\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    points = []\n    index = 1\n    \n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Calculate distances between consecutive points\n    dists = []\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % n]  # Use modulo to wrap around to the first point\n        dx = x2 - x1\n        dy = y2 - y1\n        dists.append(math.sqrt(dx*dx + dy*dy))\n    \n    # Add distance back to start\n    dists.append(math.sqrt(x1*x1 + y1*y1))\n    \n    # Sum all distances\n    total_cost = sum(dists)\n    print(\"{:.10f}\".format(total_cost))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '#' and s[i+2] == '#' and s[i+1] == '.':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    \n    count = 0\n    current_time = 0\n    \n    for i in range(n):\n        if current_time + times[i] >= c:\n            count += 1\n            \n        current_time += times[i]\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    grid = []\n    for _ in range(8):\n        grid.append(input().strip())\n    \n    count = 0\n    \n    # Check each cell\n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                valid = True\n                \n                # Check vertical capture\n                for k in range(8):\n                    if grid[k][j] == '#':\n                        valid = False\n                        break\n                \n                # Check horizontal capture\n                for k in range(8):\n                    if grid[i][k] == '#':\n                        valid = False\n                        break\n                \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if all characters are distinct\n    if len(set(s)) != 3:\n        print(\"No\")\n        return\n        \n    # Check if we have at least one 'A', one 'B', and one 'C'\n    if 'A' not in s or 'B' not in s or 'C' not in s:\n        print(\"No\")\n        return\n        \n    # Check if we have exactly one character that appears twice\n    count_A = s.count('A')\n    count_B = s.count('B')\n    count_C = s.count('C')\n    \n    if count_A == 2 and count_B == 1 and count_C == 0:\n        print(\"Yes\")\n    elif count_A == 1 and count_B == 2 and count_C == 0:\n        print(\"Yes\")\n    elif count_A == 0 and count_B == 1 and count_C == 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Precompute modular inverses up to 10^9\n    mod_inv = [0] * (10**9 + 1)\n    mod_inv[1] = 1\n    \n    for i in range(2, 10**9 + 1):\n        mod_inv[i] = (-mod_inv[10**9 % i]) % i\n    \n    results = []\n    idx = 1\n    for _ in range(n):\n        q_val = int(data[idx]); r_val = int(data[idx+1]); idx += 2\n        q_val %= 10**9\n        r_val %= 10**9\n        \n        # Compute modular inverse of q_val modulo r_val\n        inv_q = mod_inv[q_val]\n        \n        for _ in range(int(data[idx])):\n            t_val = int(data[idx+1]); d_val = int(data[idx+2]); idx += 3\n            \n            # Find smallest k such that (d_val - 1 + k*r_val) % q_val == 0\n            # This means we need to find k such that (d_val - 1) % q_val == -k*r_val\n            # Since r_val divides q_val, this simplifies to finding k such that (d_val - 1) % q_val == 0\n            # So we need to find k such that d_val % q_val == 1\n            target = (d_val - 1) % q_val\n            \n            # If target is already 0, it means d_val is divisible by q_val\n            if target == 0:\n                k = 0\n            else:\n                # Use extended Euclidean algorithm to find modular inverse and solve for k\n                def extended_gcd(a, b):\n                    if b == 0:\n                        return (1, 0, a)\n                    g, x1, y1 = extended_gcd(b, a % b)\n                    x = y1\n                    y = x1 - (a // b) * y1\n                    return (g, x, y)\n                \n                g, x, y = extended_gcd(q_val, r_val)\n                if target != 0 and g != 1:\n                    raise ValueError(\"No solution exists\")\n                elif target == 0:\n                    k = 0\n                else:\n                    # Solve k = x_target mod r_val where x_target = x * inv_q mod r_val\n                    x_target = (x * inv_q) % r_val\n                    k = (target + x_target) // r_val\n                \n            results.append(str(d_val + k))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "def main():\n    colors = list(map(int, input().split()))\n    \n    # Count frequency of each color\n    freq = {}\n    for color in colors:\n        if color in freq:\n            freq[color] += 1\n        else:\n            freq[color] = 1\n    \n    max_count = 0\n    for count in freq.values():\n        if count > max_count:\n            max_count = count\n    \n    print(max_count // 2)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = list(data[1])\n    \n    count = 0\n    start = 0\n    \n    for i in range(n):\n        if s[i] == 'O':\n            if i - start + 1 >= k:\n                count += 1\n                start = i + 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Extract digits\n    hundreds = n // 100\n    tens = (n // 10) % 10\n    units = n % 10\n    \n    # Form new numbers\n    first_number = 100 * tens + 10 * units + hundreds\n    second_number = 100 * units + 10 * hundreds + tens\n    \n    print(f\"{first_number} {second_number}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Convert number to string to easily access each digit\n    num_str = str(n)\n    \n    # Count occurrences of each digit\n    count_1 = num_str.count('1')\n    count_2 = num_str.count('2')\n    count_3 = num_str.count('3')\n    \n    # Check all conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Find all occurrences of '|' characters\n    positions = []\n    for i, char in enumerate(s):\n        if char == '|':\n            positions.append(i)\n    \n    # If no '|' found, return empty sequence\n    if not positions:\n        print(\"\")\n        return\n    \n    # Calculate total length of sequence\n    n = len(s)\n    total_length = n + 1  # because we add one extra '|' after last element\n    \n    # Initialize result list\n    result = []\n    \n    # Process each position where '|' was added\n    for pos in positions:\n        # Calculate how many '-' were added up to this position\n        count = pos\n        \n        # Add the number of elements equal to the count\n        while count > 0:\n            # The number of elements is ceil(count / (total_length // (count + 1)))\n            num_elements = (count + total_length - 1) // (total_length // (count + 1))\n            result.extend([num_elements] * (count + 1))\n            count -= num_elements * (count + 1)\n    \n    # Print the result\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    if n % 2 == 0:\n        print(\"No\")\n        return\n        \n    half = (n + 1) // 2\n    \n    # Check first condition: length must be odd\n    if n % 2 == 0:\n        print(\"No\")\n        return\n        \n    # Check second condition: first half should have only '1's\n    valid = True\n    for i in range(half):\n        if s[i] != '1':\n            valid = False\n            break\n            \n    # Check third condition: middle character should be '/'\n    if s[half] != '/':\n        valid = False\n        \n    # Check fourth condition: last half should have only '2's\n    for i in range(half, n):\n        if s[i] != '2':\n            valid = False\n            \n    print(\"Yes\" if valid else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    n = len(s)\n    \n    # Check if length is even\n    if n % 2 != 0:\n        print(\"No\")\n        return\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if all characters have count 0 or 2\n    valid = True\n    for count in freq.values():\n        if count != 0 and count != 2:\n            valid = False\n            break\n    \n    if valid:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1]\n    \n    # Count initial empty boxes\n    empty_count = s.count('.')\n    \n    for day in range(d):\n        # Find all positions with cookies\n        cookie_positions = []\n        for i, char in enumerate(s):\n            if char == '@':\n                cookie_positions.append(i)\n        \n        # If no cookies found, no change needed\n        if not cookie_positions:\n            break\n            \n        # Remove the first cookie position (earliest one)\n        cookie_positions.pop(0)\n        \n        # Update empty count\n        empty_count += len(cookie_positions)\n    \n    print(empty_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1]\n    \n    # Find all positions of '@' in reverse order\n    positions = [i+1 for i, len(s)-i] for i, c in enumerate(s[::-1]) if c == '@']\n    \n    result = []\n    current_day = 0\n    \n    while current_day < d:\n        # Check if there are any boxes with cookies available\n        if not positions:\n            break\n            \n        # Find the position of the first box with a cookie\n        first_with_cookie = None\n        for pos in positions:\n            if pos <= current_day + 1:\n                first_with_cookie = pos\n                break\n                \n        if first_with_cookie is None:\n            # No boxes with cookies available\n            result.append('.')\n        else:\n            # Add a cookie to the box\n            result.append('@')\n            # Remove the box from the list since we've used it\n            positions.remove(first_with_cookie)\n            current_day += 1\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    times = []\n    volumes = []\n    \n    index = 1\n    for i in range(n):\n        t = int(data[index]); v = int(data[index + 1])\n        times.append(t)\n        volumes.append(v)\n        index += 2\n    \n    # Initialize state with initial conditions\n    current_time = 0\n    current_water = 0\n    max_water = 0\n    \n    for i in range(n):\n        start_time = times[i]\n        end_time = times[i] + volumes[i]\n        \n        # Calculate water added during this interval\n        water_added = min(volumes[i], end_time - current_time)\n        current_water += water_added\n        \n        # Update maximum water\n        if current_water > max_water:\n            max_water = current_water\n            \n        # If we've reached the end of this interval, update current time\n        if end_time <= current_time:\n            current_time = end_time\n    \n    print(max_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    r = int(data[1])\n    \n    div_updates = []\n    idx = 2\n    for i in range(n):\n        d = int(data[idx]); a = int(data[idx + 1])\n        idx += 2\n        if d == 1:  # Div. 1\n            div_updates.append(a)\n        else:  # Div. 2\n            r += a\n    \n    print(r)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    c1 = data[1]\n    c2 = data[2]\n    s = data[3].strip()\n    \n    result = []\n    for i < n:\n        if s[i] != c1:\n            result.append(c2)\n        else:\n            result.append(s[i])\n        i += 1\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    total_sum = A + B + C\n    \n    if total_sum % 2 == 1:\n        print(\"No\")\n        return\n        \n    target = total_sum // 2\n    \n    # Check if any of the numbers is greater than the target\n    if max(A, B, C) > target:\n        print(\"No\")\n        return\n        \n    # Check if we can form two groups with equal sums\n    if target >= A and target >= B and target >= C:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    H, W, X, Y = map(int, data[0].split())\n    \n    grid = []\n    for i in range(1, 1 + H):\n        grid.append(data[i].strip())\n    \n    t_str = data[-1]\n    \n    x, y = X, Y\n    \n    for char in t_str:\n        new_x, new_y = x, y\n        \n        if char == 'U':\n            if grid[x - 1][y] == '.':\n                new_x -= 1\n        elif char == 'D':\n            if grid[x + 1][y] == '.':\n                new_x += 1\n        elif char == 'L':\n            if grid[x][y - 1] == '.':\n                new_y -= 1\n        elif char == 'R':\n            if grid[x][y + 1] == '.':\n                new_y += 1\n        \n        if 1 <= new_x <= H and 1 <= new_y <= W:\n            x, y = new_x, new_y\n    \n    visited = set()\n    count = 0\n    \n    while True:\n        pos = (x, y)\n        if pos not in visited:\n            visited.add(pos)\n            count += 1\n            \n        if grid[x][y] == '@':\n            break\n            \n        if x > 0 and grid[x - 1][y] == '.':\n            x -= 1\n        elif x < H - 1 and grid[x + 1][y] == '.':\n            x += 1\n        elif y > 0 and grid[x][y - 1] == '.':\n            y -= 1\n        else:\n            y += 1\n    \n    print(f\"{x} {y} {count}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    # Check if any number appears exactly twice\n    count_A = sum(1 for i == A for i == B)\n    count_B = sum(1 for i == B or i == C)\n    count_C = sum(1 for i == C or i == D)\n    count_D = sum(1 for i == D)\n    \n    if count_A == 2 or count_B == 2 or count_C == 2 or count_D == 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Precompute powers of 10 up to |s|\n    max_len = len(s)\n    pow10 = [1] * (max_len + 1)\n    for i in range(1, max_len + 1):\n        pow10[i] = pow10[i - 1] * 10\n    \n    # Find the longest prefix that matches a power of 10\n    best_prefix = \"\"\n    current = \"\"\n    for i in range(max_len):\n        current += s[i]\n        if int(current) <= pow10[len(current)]:\n            best_prefix = current\n        else:\n            break\n            \n    # Calculate the remaining part after the prefix\n    remaining = s[len(best_prefix):]\n    \n    # If no prefix found, use entire string\n    if not best_prefix:\n        print(len(s))\n    else:\n        # Count how many times we need to add \"0\" to get to next power of 10\n        count_zeros = 0\n        while True:\n            if int(best_prefix + '0') > pow10[len(best_prefix) + 1]:\n                break\n            count_zeros += 1\n            best_prefix += '0'\n            \n        # Add the remaining part\n        result = len(best_prefix) + count_zeros + len(remaining)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]