[
  {
    "question_id": "abc365_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    # Find the first and second largest elements\n    max_val = float('-inf')\n    second_max = float('-inf')\n    \n    for num in arr:\n        if num > max_val:\n            second_max = max_val\n            max_val = num\n        elif num > second_max and num != max_val:\n            second_max = num\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "import sys\n\ndef main():\n    y = int(sys.stdin.readline().strip())\n    \n    if (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = []\n    for i in range(1, n + 1):\n        strings.append(data[i].strip())\n    \n    max_len = max(len(s) for s in strings)\n    \n    result = []\n    for i in range(n, 0, -1):\n        current_string = strings[i-1]\n        if len(current_string) < max_len:\n            current_string += '*' * (max_len - len(current_string))\n        \n        # Find the longest common prefix\n        common_prefix_length = 0\n        for j in range(min(len(current_string), max_len)):\n            if current_string[j] == strings[0][j]:\n                common_prefix_length += 1\n            else:\n                break\n        \n        # Construct the row\n        row = ''\n        for j in range(max_len):\n            if j < common_prefix_length:\n                row += current_string[j]\n            else:\n                row += '*'\n        \n        result.append(row)\n    \n    print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    t = int(data[1])\n    a = int(data[2])\n    \n    # Check if the total votes are odd\n    if (t + a) % 2 == 0:\n        print(\"No\")\n        return\n    \n    # Calculate the difference between votes for Takahashi and Aoki\n    diff = abs(t - a)\n    \n    # If the difference is even, it means the outcome is undecided\n    if diff % 2 == 0:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    \n    # Check if there's enough time between waking up and bedtime\n    if C - B < 24:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "import sys\n\ndef main():\n    x = float(sys.stdin.readline().strip())\n    \n    # Remove trailing zeros after the decimal point\n    if '.' in str(x):\n        parts = str(x).split('.')\n        integer_part, fractional_part = parts[0], parts[1]\n        \n        # Remove trailing zeros from fractional part\n        while fractional_part and fractional_part[-1] == '0':\n            fractional_part = fractional_part[:-1]\n            \n        # Reconstruct the string with the modified fractional part\n        result = f\"{integer_part}.{fractional_part}\"\n    else:\n        result = str(x)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    # Read the list of numbers\n    arr = list(map(int, data[2:2+n]))\n    \n    # Take the last k elements (bottom k)\n    taken = arr[-k:]\n    \n    # Remove these elements from the original array\n    arr = arr[:-k]\n    \n    # Append the taken elements at the end\n    arr.extend(taken)\n    \n    # Print the result\n    print(\" \".join(map(str, arr)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    count = 0\n    while len(arr) > 1:\n        # Find the maximum element\n        max_val = max(arr)\n        \n        # Count how many times we can subtract 1 from all elements equal to max_val\n        count += arr.count(max_val)\n        \n        # Decrease all elements equal to max_val by 1\n        for i in range(len(arr)):\n            if arr[i] == max_val:\n                arr[i] -= 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    # Calculate the range of possible differences\n    min_diff = abs(a - b)\n    max_diff = abs(b - a)\n    \n    count = 0\n    \n    # Check each difference from min_diff to max_diff\n    for diff in range(min_diff, max_diff + 1):\n        # Check if we can find x such that |a-x| = diff and |b-x| = diff\n        if (abs(a - x) == diff and abs(b - x) == diff) or \\\n           (abs(a - x) == diff and abs(x - b) == diff) or \\\n           (abs(b - x) == diff and abs(a - x) == diff):\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse the input\n    presses = []\n    index = 1\n    for _ in range(n):\n        a = int(data[index]); s = data[index + 1]\n        index += 2\n        presses.append((a, s))\n    \n    # Initialize DP table: dp[i][j] = min fatigue level after processing first i presses ending at j\n    dp = [[float('inf')] * 101 for _ in range(2)]\n    dp[0][0] = 0\n    \n    for i in range(n):\n        current_hand = presses[i][1]\n        current_key = presses[i][0]\n        \n        new_dp = [[float('inf')] * 101 for _ in range(2)]\n        \n        for prev_hand in [0, 1]:\n            for k in range(101):\n                if dp[prev_hand][k] == float('inf'):\n                    continue\n                    \n                # If we're switching hands, move the previous hand to the current key\n                if prev_hand == 1 - current_hand:\n                    new_dp[current_hand][current_key] = min(new_dp[current_hand][current_key], dp[prev_hand][k] + abs(current_key - k))\n                \n                # If we're keeping the same hand, just update the current key's fatigue\n                else:\n                    new_dp[current_hand][current_key] = min(new_dp[current_hand][current_key], dp[prev_hand][k])\n                    \n        dp = new_dp\n    \n    result = min(dp[0]) + min(dp[1])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    L = int(data[0])\n    R = int(data[1])\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 1 and R == 1:\n        print(\"Invalid\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse adjacency list for directed graph\n    adj_list = [[] for _ in range(n + 1)]\n    indegree = [0] * (n + 1)\n    \n    index = 1\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            weight = int(data[index])\n            index += 1\n            if i <= j:\n                adj_list[i].append((j, weight))\n                indegree[j] += 1\n            else:\n                adj_list[j].append((i, weight))\n                indegree[i] += 1\n    \n    # Initialize queue with elements that have no incoming edges\n    queue = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    \n    # Process elements using Kahn's algorithm\n    result = []\n    while queue:\n        current = queue.popleft()\n        result.append(current)\n        \n        for neighbor, weight in adj_list[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # The result should contain all elements except the last one\n    if len(result) != n:\n        print(\"Invalid input\")\n        return\n    \n    # The last element in the result is the final answer\n    final_element = result[-1]\n    print(final_element)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Initialize list to store gender information for each family\n    genders = [None] * (n + 1)\n    \n    index = 2\n    for _ in range(m):\n        family = int(data[index]); gender = data[index+1]\n        index += 2\n        genders[family] = gender\n    \n    # Process each baby's birth\n    results = []\n    for _ in range(m):\n        family = int(sys.stdin.readline().strip())\n        gender = genders[family]\n        \n        # Check if this is the earliest born boy in his family\n        if gender == 'M':\n            results.append('Yes')\n        else:\n            results.append('No')\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    s = input().split()\n    \n    # Determine the order of ages\n    if s[0] == '<':\n        a_b = 'A'  # A is younger than B\n    else:\n        a_b = 'B'  # A is older than B\n    \n    if s[1] == '<':\n        a_c = 'A'  # A is younger than C\n    else:\n        a_c = 'C'  # A is older than C\n        \n    if s[2] == '<':\n        b_c = 'B'  # B is younger than C\n    else:\n        b_c = 'C'  # B is older than C\n        \n    # Determine the middle brother\n    if a_b == 'A' and a_c == 'A':\n        print(b_c)\n    elif a_b == 'A' and a_c == 'C':\n        print(a_b)\n    elif a_b == 'B' and a_c == 'A':\n        print(a_b)\n    elif a_b == 'B' and a_c == 'C':\n        print(b_c)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "import sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    \n    # Remove all '.' characters using list comprehension\n    result = ''.join(char for char in s if char != '.')\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    \n    count = 0\n    for i, s in enumerate(data):\n        if len(s) == i + 1:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    \n    # Create a dictionary mapping characters to their positions\n    char_to_pos = {}\n    for i, c in enumerate(data):\n        char_to_pos[c] = i + 1\n    \n    # Calculate the total distance\n    total_distance = 0\n    current_position = 1  # Start at position 1 (A)\n    \n    for c in data:\n        pos = char_to_pos[c]\n        distance = abs(pos - current_position)\n        total_distance += distance\n        current_position = pos\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    s = data[0].strip()\n    t = data[1].strip()\n    \n    for i in range(min(len(s), len(t))):\n        if s[i] != t[i]:\n            print(i + 1)\n            return\n    \n    if len(s) == len(t):\n        print(0)\n    else:\n        print(max(len(s), len(t)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "import sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    \n    if s.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse coordinates\n    points = []\n    index = 1\n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Precompute squared distances between all pairs of points\n    dists = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            dx = points[i][0] - points[j][0]\n            dy = points[i][1] - points[j][1]\n            dists[(i, j)] = dx * dx + dy * dy\n    \n    # Initialize DP table: dp[i][j] = minimum cost to reach point i from point j\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n    \n    # Process each edge once\n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            edges.append((dists[(i, j)], i, j))\n    \n    # Sort edges by distance\n    edges.sort()\n    \n    # Process edges in order of increasing distance\n    for dist, u, v in edges:\n        for k in range(n):\n            if dp[u][k] != float('inf') and dp[k][v] != float('inf'):\n                dp[u][v] = min(dp[u][v], dp[u][k] + dp[k][v])\n    \n    # Sum up costs for all segments starting and ending at the origin\n    total_cost = 0.0\n    for i in range(n):\n        total_cost += dp[0][i]\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "def main():\n    import sys\n    \n    data = sys.stdin.read().splitlines()\n    N = int(data[0])\n    S = data[1].strip()\n    \n    count = 0\n    for i in range(N - 1):\n        if S[i] == '#' and S[i+1] == '.':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    \n    presses = []\n    index = 2\n    for _ in range(n):\n        presses.append(int(data[index]))\n        index += 1\n    \n    count = 0\n    current_time = 0\n    \n    for press in presses:\n        if current_time + press >= c:\n            count += 1\n        current_time += press\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    grid = [line.strip() for line in data]\n    \n    count = 0\n    \n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                valid = True\n                \n                # Check vertical capture\n                for k in range(i + 1, 8):\n                    if grid[k][j] == '#':\n                        valid = False\n                        break\n                        \n                # Check horizontal capture\n                for k in range(j + 1, 8):\n                    if grid[i][k] == '#':\n                        valid = False\n                        break\n                        \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if all characters are distinct\n    if len(set(s)) == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    index = 1\n    \n    # Parse q_i and r_i\n    q_r_pairs = []\n    for i in range(n):\n        q = int(data[index]); r = int(data[index+1])\n        index += 2\n        q_r_pairs.append((q, r))\n    \n    # Parse Q\n    Q = int(data[index])\n    index += 1\n    \n    # Process each query\n    results = []\n    for _ in range(Q):\n        t = int(data[index]); d = int(data[index+1])\n        index += 2\n        \n        # Find the earliest day after d where t-th type of garbage is collected\n        found = False\n        for q, r in q_r_pairs:\n            if d % q == r:\n                results.append(d + 1)\n                found = True\n                break\n                \n        if not found:\n            results.append(-1)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    colors = [int(d) for d in data]\n    \n    count = {}\n    for color in colors:\n        if color not in count:\n            count[color] = 0\n        count[color] += 1\n    \n    max_count = 0\n    for freq in count.values():\n        if freq > 1:\n            max_count = max(max_count, freq - 1)\n    \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1].strip()\n    \n    max_count = 0\n    \n    # Count initial segments of length k with all O's\n    count = 0\n    for i in range(n - k + 1):\n        if all(s[i+j] == 'O' for j in range(k)):\n            count += 1\n            \n    max_count = count\n    \n    # Slide window across the string\n    for i in range(n - k + 1):\n        if s[i] == 'X':\n            continue\n            \n        # Check if we can extend the current segment\n        valid = True\n        for j in range(k):\n            if s[i + j] != 'O':\n                valid = False\n                break\n                \n        if valid:\n            count -= 1\n            if s[i+k] == 'O':\n                count += 1\n                \n        if count > max_count:\n            max_count = count\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    n = int(data)\n    \n    # Extract digits\n    hundreds = n // 100\n    tens = (n // 10) % 10\n    units = n % 10\n    \n    # Form new numbers\n    num1 = 100 * tens + 10 * units + hundreds\n    num2 = 100 * units + 10 * hundreds + tens\n    \n    print(f\"{num1} {num2}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Convert number to string to easily access each digit\n    num_str = str(n)\n    \n    # Count occurrences of each digit\n    count_1 = num_str.count('1')\n    count_2 = num_str.count('2')\n    count_3 = num_str.count('3')\n    \n    # Check conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    \n    # Find the position of the last '|' character\n    last_pipe_index = data.rfind('|')\n    \n    if last_pipe_index == -1:\n        print(\"1\")\n        return\n    \n    # Count the number of '-' characters before the last '|'\n    count_minus = data[:last_pipe_index].count('-')\n    \n    # Calculate the total number of digits\n    total_digits = len(data)\n    \n    # Calculate the number of groups of 9\n    num_groups_of_nines = total_digits // 9\n    \n    # Calculate the remaining digits after full groups of 9\n    remaining_digits = total_digits % 9\n    \n    # The first element is always 1\n    result = [1]\n    \n    # Add the remaining digits\n    for i in range(remaining_digits):\n        result.append(i + 1)\n    \n    # Add the count of '-' characters\n    result.extend([count_minus] * num_groups_of_nines)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    if len(s) != n:\n        print(\"No\")\n        return\n        \n    # Check if the first character is '1'\n    if s[0] != '1':\n        print(\"No\")\n        return\n        \n    # Check if the last character is '/'\n    if s[-1] != '/':\n        print(\"No\")\n        return\n        \n    # Check if there's exactly one '/' character\n    count_slash = 0\n    for char in s:\n        if char == '/':\n            count_slash += 1\n            \n    if count_slash != 1:\n        print(\"No\")\n        return\n        \n    # Check if the remaining characters form a valid sequence\n    start_index = 1\n    end_index = len(s) - 1\n    \n    while start_index < end_index:\n        if s[start_index] != '1' or s[end_index] != '2':\n            print(\"No\")\n            return\n            \n        start_index += 1\n        end_index -= 1\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if the length is even\n    if len(s) % 2 != 0:\n        print(\"No\")\n        return\n        \n    # Count occurrences of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            \n    # Check if each character appears exactly twice\n    for count in char_count.values():\n        if count != 2:\n            print(\"No\")\n            return\n            \n    # Check if the string is 1122 compliant\n    n = len(s)\n    valid = True\n    \n    # Check pairs of characters\n    for i in range(n):\n        if i + 1 < n:\n            if s[i] != s[i+1]:\n                valid = False\n                break\n                \n    if valid:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    # Count initial number of cookies\n    num_cookies = s.count('@')\n    \n    # Calculate remaining cookies after D days\n    remaining_cookies = num_cookies - d\n    \n    # If no cookies remain, all boxes are empty\n    if remaining_cookies <= 0:\n        print(n)\n        return\n    \n    # Calculate number of boxes with cookies\n    num_with_cookies = s.count('@')\n    \n    # Calculate number of boxes without cookies\n    num_without_cookies = n - num_with_cookies\n    \n    # Calculate number of boxes with cookies after D days\n    num_with_cookies_after_d = max(0, num_with_cookies - remaining_cookies)\n    \n    # Calculate number of boxes without cookies after D days\n    num_without_cookies_after_d = num_without_cookies - remaining_cookies\n    \n    # Total number of boxes with cookies after D days\n    total_with_cookies_after_d = num_with_cookies_after_d + num_without_cookies_after_d\n    \n    # Number of boxes that will be empty after D days\n    result = n - total_with_cookies_after_d\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    # Initialize result array\n    result = ['.'] * n\n    \n    # Process each day\n    for day in range(d):\n        # Find the last occurrence of '@' on or before current day\n        last_occurrence = -1\n        for i in range(n - 1, -1, -1):\n            if s[i] == '@':\n                last_occurrence = i\n                break\n                \n        # If no cookie found, all boxes are empty\n        if last_occurrence == -1:\n            continue\n            \n        # Update result for all boxes up to last occurrence\n        for i in range(last_occurrence + 1):\n            result[i] = '.'\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    times = []\n    volumes = []\n    index = 1\n    \n    for _ in range(n):\n        t = int(data[index]); v = int(data[index + 1])\n        index += 2\n        times.append(t)\n        volumes.append(v)\n    \n    # Initialize variables\n    current_time = 0\n    total_water = 0\n    \n    for i in range(n):\n        if current_time >= times[i]:\n            continue\n            \n        diff = times[i] - current_time\n        current_time = times[i]\n        \n        # Calculate water added during this interval\n        water_added = min(diff, volumes[i])\n        total_water += water_added\n        \n        # Update current time\n        current_time += water_added\n    \n    print(total_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "def main():\n    import sys\n    \n    data = sys.stdin.read().split()\n    \n    # Parse input\n    N = int(data[0])\n    R = int(data[1])\n    \n    arcs = []\n    index = 2\n    for i in range(N):\n        D_i = int(data[index]); A_i = int(data[index+1])\n        index += 2\n        arcs.append((D_i, A_i))\n    \n    # Process each arc\n    current_rating = R\n    for D, A in arcs:\n        if D == 1:\n            new_rating = current_rating + A\n        else:\n            new_rating = current_rating\n        current_rating = new_rating\n    \n    print(current_rating)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    c1 = data[1].strip()[0]\n    c2 = data[2].strip()[0]\n    s = data[3].strip()\n    \n    result = []\n    for char in s:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    \n    total_sum = A + B + C\n    \n    # Check if total sum is even\n    if total_sum % 2 != 0:\n        print(\"No\")\n        return\n        \n    target_sum = total_sum // 2\n    \n    # Check if we can split remaining sum into two equal parts\n    remaining_sum = total_sum - target_sum\n    if remaining_sum % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    lines = data.split('\\n')\n    \n    H, W = map(int, lines[0].split())\n    X, Y = map(int, lines[1].split())\n    grid = []\n    index = 2\n    \n    for _ in range(H):\n        grid.append(lines[index])\n        index += 1\n        \n    T = lines[index]\n    \n    current_x, current_y = X - 1, Y - 1\n    \n    visited = set()\n    visited.add((current_x, current_y))\n    \n    directions = {\n        'U': (-1, 0),\n        'D': (1, 0),\n        'L': (0, -1),\n        'R': (0, 1)\n    }\n    \n    houses_passed = set()\n    \n    for char in T:\n        dx, dy = directions[char]\n        \n        new_x = current_x + dx\n        new_y = current_y + dy\n        \n        while 0 <= new_x < H and 0 <= new_y < W and grid[new_x][new_y] != '#':\n            if grid[new_x][new_y] == '@':\n                houses_passed.add((new_x, new_y))\n            \n            visited.add((new_x, new_y))\n            current_x, current_y = new_x, new_y\n            \n            new_x = current_x + dx\n            new_y = current_y + dy\n    \n    print(f\"{current_x + 1} {current_y + 1} {len(houses_passed)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    D = int(data[3])\n    \n    # Count occurrences of each number\n    count_A = [0] * 13\n    count_B = [0] * 13\n    count_C = [0] * 13\n    count_D = [0] * 13\n    \n    count_A[A - 1] += 1\n    count_B[B - 1] += 1\n    count_C[C - 1] += 1\n    count_D[D - 1] += 1\n    \n    # Check for at least two numbers with count 3\n    has_three_of_a_kind_A = False\n    has_three_of_a_kind_B = False\n    has_three_of_a_kind_C = False\n    has_three_of_a_kind_D = False\n    \n    for i in range(13):\n        if count_A[i] == 3:\n            has_three_of_a_kind_A = True\n        elif count_B[i] == 3:\n            has_three_of_a_kind_B = True\n        elif count_C[i] == 3:\n            has_three_of_a_kind_C = True\n        elif count_D[i] == 3:\n            has_three_of_a_kind_D = True\n            \n    # Check for at least one pair\n    has_pair_A = False\n    has_pair_B = False\n    has_pair_C = False\n    has_pair_D = False\n    \n    for i in range(13):\n        if count_A[i] >= 2:\n            has_pair_A = True\n        elif count_B[i] >= 2:\n            has_pair_B = True\n        elif count_C[i] >= 2:\n            has_pair_C = True\n        elif count_D[i] >= 2:\n            has_pair_D = True\n            \n    # Check if we have both a three-of-a-kind and a pair\n    if (has_three_of_a_kind_A or has_three_of_a_kind_B or has_three_of_a_kind_C or has_three_of_a_kind_D) and \\\n       (has_pair_A or has_pair_B or has_pair_C or has_pair_D):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "import sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    \n    # Precompute factorials up to 10^9 for modulo operations\n    mod = 10**9 + 7\n    fact = [1] * (len(s) + 1)\n    inv_fact = [1] * (len(s) + 1)\n    \n    for i in range(1, len(s) + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    for i in range(len(s), 0, -1):\n        inv_fact[i - 1] = pow(fact[i], mod - 2, mod)\n    \n    result = 0\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] == '0':\n            continue\n            \n        # Count occurrences of each digit\n        count = [0] * 10\n        for j in range(i, n):\n            count[int(s[j])] += 1\n        \n        # Calculate contribution for current position\n        contrib = 0\n        for d in range(10):\n            if count[d] > 0:\n                # Choose k digits from d, where k ranges from 0 to count[d]\n                # We need to choose at least one digit, so we start from 1\n                total_ways = fact[count[d]]\n                for k in range(1, count[d] + 1):\n                    ways = fact[k] * inv_fact[count[d] - k] % mod\n                    total_ways = (total_ways * ways) % mod\n                \n                # Multiply by the number of ways to place these digits\n                # There are count[d] positions for these digits\n                # We need to choose k positions out of count[d] for the first digit,\n                # then k-1 positions for the second digit, etc., until all digits are placed\n                # This is equivalent to choosing k positions out of count[d] for the first digit,\n                # which is C(count[d], k)\n                # But since we are choosing k positions for each digit independently,\n                # it's simply count[d]!\n                # However, we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # So we multiply by count[d]! / (k-1)!\n                # But we also need to divide by count[d]! / (k-2)! for the third digit, etc.,\n                # but we only need to do this for the second last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count[d], k)\n                # But we need to divide by k! because we are overcounting by the permutations of the digits\n                # So we multiply by count[d]! / k!\n                # But we also need to divide by count[d]! / (k-1)! for the second digit, etc.,\n                # but we only need to do this for the last digit\n                # And so on...\n                # But we can simplify this by noting that we are essentially choosing k positions out of count[d],\n                # which is C(count"
    ]
  }
]